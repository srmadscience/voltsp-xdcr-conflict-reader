package org.voltdb.xdcrutil;

import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import org.voltdb.client.Client;
import org.voltdb.client.NoConnectionsException;
import org.voltdb.client.ProcCallException;
import org.voltdb.client.ProcedureCallback;
import org.voltdb.types.*;

import com.google.gson.Gson;

/**
 * Java representation of a VoltDB XDCR conflict message.
 *
 */
public class XdcrConflictMessage {

	// Metadata columns
	// See https://docs.voltdb.com/UsingVoltDB/exportexport.php#ExportMetadataTable

    public long m_transactionId;

	public TimestampType m_exportGenerationTime;

	public long m_seqno;

	public long m_partitionId;

	public long m_siteId;

	public byte m_exportOperation;

	// XDCR Columns
	// See https://docs.voltdb.com/UsingVoltDB/DbRepHowToActive.php#DbRepActiveLogTab

	public TimestampType m_eventTime;

	public XdcrRowType m_rowType;

	public XdcrActionType m_actionType;

	public XdcrConflictType m_conflictType;

	public boolean m_primaryKeyConflict;

	public boolean m_wasAccepted;

	public byte m_lastModClusterId;

	public TimestampType m_rowTimeststamp;

	boolean m_isStillConsistent;

	public String m_tableName;

	public byte m_currentClusterId;

	public TimestampType m_conflictTimeststamp;

	public String m_JsonEncodedTuple;
		
	//Derived PK
	
	public String m_pk;
	
	// Old value - filled in for NEW records
	
	public String m_oldJsonEncodedTuple;
       

	
	Gson gson = new Gson(); //TODO slow

	/**
	 * @param key - assumed to be unixtime
	 * @param message - CSV generated by VoltDB's XDCR conflict resolver.
	 * @throws XdcrFormatException 
	 */
	public XdcrConflictMessage(String key, String message) throws XdcrFormatException {

		try {
			this.m_eventTime = new TimestampType(Long.parseLong(key));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized event time : " + key);
		}

		// Most of the message can be handled by splitting based on ','.
		String[] payload = message.split("\",\"");

		try {
			m_transactionId = Long.parseLong(payload[0].replace("\"", ""));
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized transactionId : " + payload[0]);
		}

		try {
			m_exportGenerationTime = new TimestampType(Long.parseLong(payload[1]));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized exportGenerationTime : " + payload[0]);
		}

		try {
			m_seqno = Long.parseLong(payload[2]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized seqno : " + payload[2]);
		}

		try {
			m_partitionId = Long.parseLong(payload[3]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized partitionId : " + payload[3]);
		}

		try {
			m_siteId = Long.parseLong(payload[4]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized siteId : " + payload[3]);
		}

		try {
			m_exportOperation = Byte.parseByte(payload[5]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized exportOperation : " + payload[5]);
		}

		m_rowType = XdcrUtils.getRowType(payload[6]);
		m_actionType = XdcrUtils.getActionType(payload[7]);
		m_conflictType = XdcrUtils.getConflictType(payload[8]);

		if (payload[9].equals("1")) {
			m_primaryKeyConflict = true;
		} else if (payload[9].equals("0")) {
			m_primaryKeyConflict = false;
		} else {
			throw new XdcrFormatException("Unrecognized primaryKeyConflict: " + payload[9]);
		}

		if (payload[10].equals("A")) {
			m_wasAccepted = true;
		} else if (payload[10].equals("R")) {
			m_wasAccepted = false;
		} else {
			throw new XdcrFormatException("Unrecognized DECISION: " + payload[10]);
		}

		try {
			m_lastModClusterId = Byte.parseByte(payload[11]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized last mod cluster id: " + payload[11]);
		}

		try {
			m_rowTimeststamp = new TimestampType(Long.parseLong(payload[12]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized row timestamp: " + payload[12]);
		}

		if (payload[13].equals("C")) {
			m_isStillConsistent = true;
		} else if (payload[13].equals("D")) {
			m_isStillConsistent = false;
		} else {
			throw new XdcrFormatException("Unrecognized DIVERGENCE: " + payload[13]);
		}

		m_tableName = payload[14];

		try {
			m_currentClusterId = Byte.parseByte(payload[15]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized current cluster id: " + payload[15]);
		}

		try {
			m_conflictTimeststamp = new TimestampType(Long.parseLong(payload[16]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized conflict timestamp: " + payload[16]);
		}

		
		// The last part of the message is a JSON tuple. Because this has embedded ,'s we 
		// don't use the String[] we created earlier. Instead we figure out where it starts.
		int startOfTuple = 0;

		for (int i = 0; i <= 16; i++) {
			startOfTuple += payload[i].length() + 3;
		}

		m_JsonEncodedTuple = message.substring(startOfTuple);
		m_JsonEncodedTuple = m_JsonEncodedTuple.substring(0,m_JsonEncodedTuple.length()-1);

		m_JsonEncodedTuple = m_JsonEncodedTuple.replace("\"\"", "\"");

		if (m_JsonEncodedTuple.equals("NULL\"")) {
			m_JsonEncodedTuple = "";
		} else {
			// Try and create UserTable entry
			
			// Replace field names so GSON will work...
			String alteredJson = new String(m_JsonEncodedTuple);
			
			
			
		}
		
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", exportGenerationTime=");
		builder.append(m_exportGenerationTime);
		builder.append(", seqno=");
		builder.append(m_seqno);
        
        builder.append(", PK=");
        builder.append(m_pk);
        
        builder.append(", partitionId=");
        builder.append(m_partitionId);
		
		builder.append(", siteId=");
		builder.append(m_siteId);
		builder.append(", exportOperation=");
		builder.append(m_exportOperation);
		builder.append(", eventTime=");
		builder.append(m_eventTime);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", primaryKeyConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", wasAccepted=");
		builder.append(m_wasAccepted);
		builder.append(", lastModClusterId=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", isConsistant=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
		builder.append(", currentClusterId=");
		builder.append(m_currentClusterId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", tuple=");
		builder.append(m_JsonEncodedTuple);
		builder.append("]");
		return builder.toString();
	}

	/**
	 * @return A String with a subset of useful columns
	 */
	public String toShortString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", cc=");
		builder.append(m_currentClusterId);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", pkConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", ok=");
		builder.append(m_wasAccepted);
		builder.append(", lmc=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", con=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
        builder.append(", tuple=");
        builder.append(m_JsonEncodedTuple);
        builder.append(", oldTuple=");
        builder.append(m_oldJsonEncodedTuple);
		
		
		
		builder.append("]");
		return builder.toString();
	}

	/**
	 * Insert this row into VoltDB.
	 * @param theCallback
	 * @param theClient
	 * @param xdcrTableName
	 * @throws NoConnectionsException
	 * @throws IOException
	 * @throws ProcCallException
	 */
	public void insertToVoltDB(ProcedureCallback theCallback, Client theClient, String xdcrTableName)
			throws NoConnectionsException, IOException, ProcCallException {

			theClient.callProcedure(theCallback,xdcrTableName + ".insert",
					// Metadata columns
					m_transactionId,
					m_exportGenerationTime,
					m_seqno,
					m_partitionId,
					m_siteId,
					m_exportOperation,
					// XDCR Columns
					m_eventTime,
					m_rowType.toString(),
					m_actionType.toString(),
					m_conflictType.toString(),
					XdcrUtils.mapBooleanToInt(m_primaryKeyConflict),
					XdcrUtils.mapBooleanToInt(m_wasAccepted),
					m_lastModClusterId,
					m_rowTimeststamp,
					XdcrUtils.mapBooleanToInt(m_isStillConsistent),
					m_tableName,
					m_currentClusterId,
					m_conflictTimeststamp,
					new Date(System.currentTimeMillis()),
					m_JsonEncodedTuple
			);
		

	}
	
	/**
     * Insert this row into VoltDB.
     * @param theCallback
     * @param theClient
     * @param procedureName
     * @throws NoConnectionsException
     * @throws IOException
     * @throws ProcCallException
     */
    public void insertToVoltDBUsingProcedure(ProcedureCallback theCallback, Client theClient, String procedureName)
            throws NoConnectionsException, IOException, ProcCallException {

            theClient.callProcedure(theCallback,procedureName ,
                    // Metadata columns
                    m_transactionId,
                    m_exportGenerationTime,
                    m_seqno,
                    m_partitionId,
                    m_siteId,
                    m_exportOperation,
                    // XDCR Columns
                    m_eventTime,
                    m_rowType.toString(),
                    m_actionType.toString(),
                    m_conflictType.toString(),
                    XdcrUtils.mapBooleanToInt(m_primaryKeyConflict),
                    XdcrUtils.mapBooleanToInt(m_wasAccepted),
                    m_lastModClusterId,
                    m_rowTimeststamp,
                    XdcrUtils.mapBooleanToInt(m_isStillConsistent),
                    m_tableName,
                    m_currentClusterId,
                    m_conflictTimeststamp,
                    m_JsonEncodedTuple
            );
        

    }

	/**
	 * Convenience method to create needed DDL. Note that we don't 'DR' this table.
	 * @param tableName
	 * @param partitionColumnName
	 * @param jsonColSize
	 * @return a String[] containing DDL statements.
	 */
	public static String[] toDDL(String tableName, String partitionColumnName, int jsonColSize) {

		String[] results = new String[4];

		StringBuilder builder = new StringBuilder();

		builder.append("DROP TABLE ");
		builder.append(tableName);
		builder.append(" IF EXISTS;");

		results[0] = builder.toString();

		builder = new StringBuilder();

		builder.append("CREATE TABLE ");
		builder.append(tableName);
		builder.append("(transactionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportGenerationTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",seqno BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",partitionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",siteId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportOperation TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",eventTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrRowType VARCHAR(3) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrActionType VARCHAR(1) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrConflictType VARCHAR(4) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",primaryKeyConflict TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",wasAccepted TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",lastModClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",rowTimestamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",isConsistant TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tableName VARCHAR(80) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",currentClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",conflictTimestamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",inserttime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tupleJson VARCHAR(");
		builder.append(jsonColSize);
		builder.append(") ");
		builder.append(System.lineSeparator());

		builder.append(");");
		builder.append(System.lineSeparator());

		results[1] = builder.toString();
		builder = new StringBuilder();

		builder.append("PARTITION TABLE ");
		builder.append(tableName);
		builder.append(" ON COLUMN ");
		builder.append(partitionColumnName);
		builder.append(";");

		results[2] = builder.toString();

        builder = new StringBuilder();

        builder.append("CREATE INDEX ");
        builder.append(tableName);
        builder.append("_IX1 ON ");
        builder.append(tableName);
        builder.append(" (transactionId, CONFLICTTIMESTAMP, ");
        builder.append(partitionColumnName);
        builder.append(")");
        builder.append(";");

        results[3] = builder.toString();
        

        
		return results;
	}

    /**
     * @return the m_transactionId
     */
    public long getTransactionId() {
        return m_transactionId;
    }

    /**
     * @return the m_exportGenerationTime
     */
    public TimestampType getExportGenerationTime() {
        return m_exportGenerationTime;
    }

    /**
     * @return the m_seqno
     */
    public long getSeqno() {
        return m_seqno;
    }

    /**
     * @return the m_partitionId
     */
    public long getPartitionId() {
        return m_partitionId;
    }

    /**
     * @return the m_siteId
     */
    public long getSiteId() {
        return m_siteId;
    }

    /**
     * @return the m_exportOperation
     */
    public byte getExportOperation() {
        return m_exportOperation;
    }

    /**
     * @return the m_eventTime
     */
    public TimestampType getEventTime() {
        return m_eventTime;
    }

    /**
     * @return the m_rowType
     */
    public XdcrRowType getRowType() {
        return m_rowType;
    }

    /**
     * @return the m_actionType
     */
    public XdcrActionType getActionType() {
        return m_actionType;
    }

    /**
     * @return the m_conflictType
     */
    public XdcrConflictType getConflictType() {
        return m_conflictType;
    }

    /**
     * @return the m_primaryKeyConflict
     */
    public boolean isPrimaryKeyConflict() {
        return m_primaryKeyConflict;
    }

    /**
     * @return the m_wasAccepted
     */
    public boolean wasAccepted() {
        return m_wasAccepted;
    }

    /**
     * @return the m_lastModClusterId
     */
    public byte getLastModClusterId() {
        return m_lastModClusterId;
    }

    /**
     * @return the m_rowTimeststamp
     */
    public TimestampType getRowTimeststamp() {
        return m_rowTimeststamp;
    }

    /**
     * @return the m_isStillConsistent
     */
    public boolean isStillConsistent() {
        return m_isStillConsistent;
    }

    /**
     * @return the m_tableName
     */
    public String getTableName() {
        return m_tableName;
    }

    /**
     * @return the m_currentClusterId
     */
    public byte getCurrentClusterId() {
        return m_currentClusterId;
    }

    /**
     * @return the m_conflictTimeststamp
     */
    public TimestampType getConflictTimeststamp() {
        return m_conflictTimeststamp;
    }

    /**
     * @return the m_JsonEncodedTuple
     */
    public String getJsonEncodedTuple() {
        return m_JsonEncodedTuple;
    }

    /**
     * @return the gson
     */
    public Gson getGson() {
        return gson;
    }

 

    /**
     * @param gson the gson to set
     */
    public void setGson(Gson gson) {
        this.gson = gson;
    }

    public void setPk(HashMap<String, List<String>> pkMap) {
        
        m_pk =  m_tableName + XdcrUtils.getPk(this, pkMap);
        
    }

    /**
     * @return the m_pk
     */
    public String getM_pk() {
        return m_pk;
    }

    
    public String getConflictPK () {
        
        //tablename, CURRENTCLUSTERID, rowpk, CONFLICTTIMESTAMP, XDCRROWTYPE,partitionId
        
        StringBuffer b = new StringBuffer(m_tableName);
        b.append('\t');
        b.append(m_currentClusterId);
        b.append('\t');
        b.append(m_pk);
        b.append('\t');
        b.append(m_conflictTimeststamp.toString());
        b.append('\t');
        b.append(m_rowType);
   
        return b.toString(); 
    }

    /**
     * @return the m_oldJsonEncodedTuple
     */
    public String getOldJsonEncodedTuple() {
        return m_oldJsonEncodedTuple;
    }

    /**
     * @param m_oldJsonEncodedTuple the m_oldJsonEncodedTuple to set
     */
    public void setOldJsonEncodedTuple(String m_oldJsonEncodedTuple) {
        this.m_oldJsonEncodedTuple = m_oldJsonEncodedTuple;
    }
	
	
	
}
